#include "zlgconfig.h"
#include "oled.h"
unsigned char GUIBUF[128][8] = {0};
/****************************************************************************
* 名称：GUI_Initialize()
* 功能：初始化GUI，包括初始化显示缓冲区，初始化LCM并清屏。
* 入口参数：无
* 出口参数：无
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
void  GUI_Initialize(void)
{
	oled_init();
}


/****************************************************************************
* 名称：GUI_FillSCR()
* 功能：全屏填充。直接使用数据填充显示缓冲区。
* 入口参数：dat		填充的数据
* 出口参数：无
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
void  GUI_FillSCR(TCOLOR dat)
{
	unsigned char i,j;
	
	for(i=0; i<8; i++)
	{
		for(j=0; j<128; j++)
		{
			GUIBUF[j][i] = dat;
		}
	}
}


/****************************************************************************
* 名称：GUI_ClearSCR()
* 功能：清屏。
* 入口参数：无
* 出口参数：无
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
void  GUI_ClearSCR()
{
	uint8_t i,n;		    
	for(i=0;i<8;i++)  
	{  
		OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）
		OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置―列低地址
		OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置―列高地址   
		for(n=0;n<128;n++)GUIBUF[n][i]=0; 
}
}


/****************************************************************************
* 名称：GUI_Point()
* 功能：在指定位置上画点。
* 入口参数： x		指定点所在列的位置
*            y		指定点所在行的位置
*            color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：返回值为1时表示操作成功，为0时表示操作失败。(操作失败原因是指定地址超出有
*          效范围)
* 说明：用户根据LCM的实际情况编写此函数。
****************************************************************************/
uint8  GUI_Point(uint16 x, uint16 y, TCOLOR color)
{	
	if( x>(GUI_LCM_XMAX) ) return(0);
	if( y>(GUI_LCM_YMAX) ) return(0);

	if(color)
	{
		GUIBUF[x][y / 8] |= (1 << (y % 8));
	}
	else
	{
		GUIBUF[x][y / 8] &= ~(1 << (y % 8));
	}
	
	return(1);
}


/****************************************************************************
* 名称：GUI_ReadPoint()
* 功能：读取指定点的颜色。
* 入口参数：x		指定点所在列的位置
*           y		指定点所在行的位置
*           ret     保存颜色值的指针
* 出口参数：返回0表示指定地址超出缓冲区范围
* 说明：对于单色，设置ret的d0位为1或0，4级灰度则为d0、d1有效，8位RGB则d0--d7有效，
*      RGB结构则R、G、B变量有效。
****************************************************************************/
uint8  GUI_ReadPoint(uint16 x, uint16 y, TCOLOR *ret)
{
	if( x>(GUI_LCM_XMAX-8) ) return(0);
	if( y>(GUI_LCM_YMAX-8) ) return(0);
	
	if((GUIBUF[x][y / 8] & (1<<(y % 8))) == 0)
		*ret = 0;
	else
		*ret = 1;
	return(1);
}


/****************************************************************************
* 名称：GUI_HLine()
* 功能：画水平线。
* 入口参数： x0		水平线起点所在列的位置
*           y0		水平线起点所在行的位置
*           x1      水平线终点所在列的位置
*           color	显示颜色(对于黑白色LCM，为0时灭，为1时显示)
* 出口参数：无
* 说明：对于单色、4级灰度的液晶，可通过修改此函数作图提高速度，如单色LCM，可以一次更
*      新8个点，而不需要一个点一个点的写到LCM中。
****************************************************************************/
void  GUI_HLine(uint16 x0, uint16 y0, uint16 x1, TCOLOR color)
{
	unsigned char i;
	if(color)
	{
		for(i=x0; i<x1; i++)
		{
			GUIBUF[i][y0 / 8] |= (1<<(y0 % 8));
		}
	}
	else
	{
		for(i=x0; i<x1; i++)
		{
			GUIBUF[i][y0 / 8] &= ~(1<<(y0 % 8));
		}
	}
}

/****************************************************************************
* 名称：GUI_RLine()
* 功能：画垂直线。
* 入口参数： x0		垂直线起点所在列的位置
*           y0		垂直线起点所在行的位置
*           y1      垂直线终点所在行的位置
*           color	显示颜色
* 出口参数：无
* 说明：对于单色、4级灰度的液晶，可通过修改此函数作图提高速度，如单色LCM，可以一次更
*      新8个点，而不需要一个点一个点的写到LCM中。
****************************************************************************/
void  GUI_RLine(uint16 x0, uint16 y0, uint16 y1, TCOLOR color)
{
	unsigned char temp1,temp2,temp3,temp4,i;
	temp1 = y0 / 8;
	temp2 = y0 % 8;
	temp3 = y1 / 8;
	temp4 = y1 % 8;
	
	if(color)
	{
		GUIBUF[x0][temp1] |= (0xff - (1<<temp2) + 1);
		GUIBUF[x0][temp3] |= (1<<temp4 + 1<<temp4 - 1);
		for(i=temp1+1; i<temp3; i++)
		{
			GUIBUF[x0][i] = 0xff;
		}
	}
	else
	{
		GUIBUF[x0][temp1] &= ~(0xff - (1<<temp2) + 1);
		GUIBUF[x0][temp3] &= ~(1<<temp4 + 1<<temp4 - 1);
		for(i=temp1+1; i<temp3; i++)
		{
			GUIBUF[x0][i] = 0;
		}
	}
}
void GUI_Exec(void)
{
    uint8_t i,n;         
    for(i=0;i<8;i++)  
    {  
        OLED_WR_Byte(0xb0+i,OLED_CMD);   //设置页地址（0~7）
        OLED_WR_Byte(0x00,OLED_CMD);      //设置显示位置―列低地址
        OLED_WR_Byte(0x10,OLED_CMD);      //设置显示位置―列高地址   
        for(n=0;n<128;n++)OLED_WR_Byte(GUIBUF[n][i],OLED_DATA); 
    }   
}
